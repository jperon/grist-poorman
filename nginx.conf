env DOMAIN;
env EMAIL;
env HTTPS;
env STAGING;

events { worker_connections 1024; }
worker_processes auto;
worker_cpu_affinity auto;

error_log /dev/stdout warn;

http {
  include       mime.types;
  types {
    application/javascript mjs;
  }
  default_type  application/octet-stream;
  lua_shared_dict gristusers 12m;
  client_header_buffer_size 5120k;
  large_client_header_buffers 16 5120k;
  log_format details '$remote_addr - $remote_user [$time_local]  '
    '"$request" $status $sent_http_content_type $body_bytes_sent '
    '"$http_referer" "$http_user_agent"';
  access_log /dev/stdout details;


  map $http_upgrade $connection_upgrade {
      default upgrade;
      ''      close;
  }

  resolver 1.1.1.3 ipv6=off;
  lua_shared_dict acme 16m;
  # required to verify Let's Encrypt API
  lua_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
  lua_ssl_verify_depth 2;

  init_by_lua_block {
    -- Load persistent authenticated sessions from file
    local f = io.open("/etc/nginx/sessions", "r")
    if f then
      for line in f:lines() do
        local token, email = line:match("^(%S+)%s+(.+)$")
        if token and email then
          ngx.shared.gristusers:set(token, email)
        end
      end
      f:close()
    end

    if os.getenv("HTTPS") == "auto" then
      local provider = os.getenv("ACME_PROVIDER")
      local options = {
        tos_accepted = true,
        account_key_path = "/usr/local/openresty/nginx/conf/account.key",
        account_email = os.getenv("EMAIL"),
        domain_whitelist = { os.getenv("DOMAIN") },
        storage_adapter = "file",
        storage_config = {
          dir = "/etc/nginx/acme"
        }
      }
      local acme_config = {}

      if provider == "actalis" then
        acme_config.api_uri = "https://acme-api.actalis.com/acme/directory"
        acme_config.eab_kid = os.getenv("EAB_KID")
        acme_config.eab_hmac_key = os.getenv("EAB_HMAC_KEY")
      elseif provider == "zerossl" then
        acme_config.api_uri = "https://acme.zerossl.com/v2/DV90"
        acme_config.eab_kid = os.getenv("EAB_KID")
        acme_config.eab_hmac_key = os.getenv("EAB_HMAC_KEY")
      elseif provider == "google" then
        acme_config.api_uri = "https://dv.acme-v02.api.pki.goog/directory"
        acme_config.eab_kid = os.getenv("EAB_KID")
        acme_config.eab_hmac_key = os.getenv("EAB_HMAC_KEY")
      else
        -- Default to Let's Encrypt
        options.staging = (os.getenv("STAGING") == "true")
      end

      require("resty.acme.autossl").init(options, acme_config)
    end
  }

  init_worker_by_lua_block {
    if os.getenv("HTTPS") == "auto" then
      local autossl = require("resty.acme.autossl")
      autossl.init_worker()
      -- Pre-fetch certificates on startup for worker 0
      if ngx.worker.id() == 0 then
        ngx.timer.at(0, function()
          local domain = os.getenv("DOMAIN")
          if domain then
            for _, typ in ipairs(autossl.config.domain_key_types) do
              if not autossl.get_certkey(domain, typ) then
                autossl.update_cert({ domain = domain, renew = false, tries = 0, type = typ })
              end
            end
          end
        end)
      end
    end
  }

  server {
    listen 80 default_server;
    listen [::]:80 default_server;
    listen 443 ssl default_server;
    listen [::]:443 ssl default_server;
    server_name _;
    root /srv;
    ssl_certificate /etc/nginx/ssl.d/cert.pem;
    ssl_certificate_key /etc/nginx/ssl.d/key.pem;
    #ssl_certificate ssl.d/default.pem;
    #ssl_certificate_key ssl.d/default.key;
    ssl_certificate_by_lua_block { if os.getenv("HTTPS") == "auto" then require("resty.acme.autossl").ssl_certificate() end }
    location /.well-known {
      content_by_lua_block { require("resty.acme.autossl").serve_http_challenge() }
    }
    proxy_connect_timeout 900;
    proxy_send_timeout 900;
    proxy_read_timeout 900;
    send_timeout 900;
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_min_length 256;
    gzip_types
      application/atom+xml
      application/geo+json
      application/javascript
      application/x-javascript
      application/json
      application/ld+json
      application/manifest+json
      application/rdf+xml
      application/rss+xml
      application/xhtml+xml
      application/xml
      font/eot
      font/otf
      font/ttf
      image/svg+xml
      text/css
      text/javascript
      text/plain
      text/xml;
    location / {
      set $grist_user '';
      rewrite_by_lua_block {
        local auth = ngx.var.cookie_gristauth
        local usr = ngx.shared.gristusers:get(auth)
        if usr then
          ngx.var.grist_user = usr
        else
          ngx.var.grist_user = ""
        end
      }
      proxy_pass http://grist:8484;
      proxy_headers_hash_bucket_size 256;
      proxy_headers_hash_max_size 2048;
      #sendfile off;
      proxy_pass_header Content-Type;
      proxy_set_header X-Forwarded-User $remote_user;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header x-forwarded-user $grist_user;
      proxy_set_header X-Forwarded-Proto $scheme;
      # WebSocket support
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;
    }
    location /logout {
      rewrite_by_lua_block {
        local auth = ngx.var.cookie_gristauth
        ngx.shared.gristusers:delete(auth)
        -- Remove session from persistent file
        local lines = {}
        local f = io.open("/etc/nginx/sessions", "r")
        if f then
          for line in f:lines() do
            if not line:match("^" .. auth .. "%s") then
              lines[#lines + 1] = line
            end
          end
          f:close()
        end
        f = io.open("/etc/nginx/sessions", "w")
        if f then
          for _, line in ipairs(lines) do f:write(line .. "\n") end
          f:close()
        end
        ngx.header["Set-Cookie"] = "gristauth=; path=/; Max-Age=0"
        ngx.redirect("/login")
      }
    }
    location /auth/login {
      rewrite ^/auth/login /login last;
    }
    location /login {
      default_type 'text/html';
      rewrite_by_lua_block {
        ngx.req.read_body()
        local random = require"resty.random"
        local str = require"resty.string"
        local data = ngx.req.get_post_args()
        if (data.nom and data.pwd) then
          -- The "gsub" parts are mandatory to avoid injections.
          local cmd = "htpasswd -vb /etc/nginx/users '" .. data.nom:gsub("'", "\\'") .. "' '" .. data.pwd:gsub("'", "\\'") .. "' 2>&1"
          local p, err = io.popen(cmd)
          local ret = p:read"*a"
          p:close()
          local success = ret:match("correct")
          if success then
            local auth = str.to_hex(random.bytes(20))
            ngx.shared.gristusers:set(auth, data.nom)
            ngx.header["Set-Cookie"] = "gristauth=" .. auth .. "; path=/"
            -- Persist session to file
            local sf = io.open("/etc/nginx/sessions", "a")
            if sf then sf:write(auth .. " " .. data.nom .. "\n"); sf:close() end
            local args = ngx.req.get_uri_args()
            ngx.redirect(args.next or '/')
          end
        end
        ngx.print([[
        <!doctype html><html lang="en" style="color-scheme:dark;color:lightgrey;">
          <head>
            <meta charset="utf8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
          </head>
          <body>
            <div style="width:50%;">
              <h1>Login</h1>
              <form method="post">
                <label for="nom">Email :</label><br/>
                <input type="text" name="nom" id="nom" value="" required><br/>
                <label for="pwd">Password :</label><br/>
                <input type="password" name="pwd" id="pwd" required><br/>
                <input type="submit" value="OK">
              </form>
              <p><br/><a href="/credentials">Create an account / Change password</a></p>
            </div>
          </body>
        </html>
        ]])
      }
    }
    location /credentials {
      default_type 'text/html';
      content_by_lua_block {
        ngx.req.read_body()
        local args = ngx.req.get_uri_args()
        local data = ngx.req.get_post_args()
        local auth = ngx.var.cookie_gristauth
        local usr = ngx.shared.gristusers:get(auth)
        
        -- Query sqlite database for owners
        local cmd_sql = [[sqlite3 /srv/persist/home.sqlite3 "SELECT l.email FROM orgs o JOIN acl_rules ar ON ar.org_id = o.id AND ar.type = 'AclRuleOrg' AND ar.permissions = 63 JOIN group_users gu ON gu.group_id = ar.group_id JOIN users u ON u.id = gu.user_id LEFT JOIN logins l ON l.user_id = u.id WHERE o.domain IS NOT NULL AND o.owner_id IS NULL;"]]
        local p_sql = io.popen(cmd_sql)
        local owners_output = p_sql:read("*a") or ""
        p_sql:close()
        
        local owners = {}
        for email in owners_output:gmatch("[^\r\n]+") do
          owners[email] = true
        end

        -- Check if at least one owner has a password configured in htpasswd
        local owners_have_password = false
        local f_ht = io.open("/etc/nginx/users", "r")
        if f_ht then
          local ht_content = f_ht:read("*a") or ""
          f_ht:close()
          for owner_email, _ in pairs(owners) do
            -- Look for "email:" at the start of a line
            if ht_content:match("(^|\n)" .. owner_email:gsub("%.", "%%.") .. ":") then
              owners_have_password = true
              break
            end
          end
        end

        local admin = false
        if not owners_have_password then
          -- If no owner has a password, it's the initial setup, open to everyone
          admin = true
        elseif owners[usr] then
          -- The logged-in user is an owner
          admin = true
        end

        local is_new_account = false
        if data.nom then
          -- Check if the requested account already exists in htpasswd
          local f_ht2 = io.open("/etc/nginx/users", "r")
          local account_exists = false
          if f_ht2 then
            local ht_content2 = f_ht2:read("*a") or ""
            f_ht2:close()
            if ht_content2:match("(^|\n)" .. data.nom:gsub("%.", "%%.") .. ":") then
              account_exists = true
            end
          end
          if not account_exists then
            is_new_account = true
          end
        end

        -- Allow action if:
        -- 1. admin is true (initial setup or owner)
        -- 2. data.nom == usr (changing own password)
        -- 3. is_new_account is true (creating a new account)
        -- Otherwise, block access to the changing logic.
        if data.nom and (admin or data.nom == usr or is_new_account) and (data.pwd == data.confirm) then
          local cmd = "htpasswd -i /etc/nginx/users '" .. data.nom:gsub("'", "\\'") .. "'"
          local p, err = io.popen(cmd, "w")
          local ok, err2 = pcall(function()
            p:write((data.pwd:gsub("'", "\\'")))  -- two parentheses to keep only 1st result of gsub
            p:close()
          end)
          if ok then return ngx.redirect(args.next or "/") end
          ngx.say(err, " - ", err2)
          return
        else
          ngx.print([[
          <!doctype html><html lang="en" style="color-scheme:dark;color:lightgrey;">
            <head>
              <meta charset="utf8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
            </head>
            <body>
              <div style="width:50%;">]] .. (
              data.nom
              and (
                data.pwd ~= data.confirm and "<span><p><strong>Passwords don't match.</strong></p></span>"
                or "<p><strong>You don't have right to set user " .. data.nom .. ".</strong></p>"
              )
              or ""
            ).. [[
              <form method="post">
                <label>Email :<br/>
                  <input type="text" name="nom" id="nom" value="]] .. (args.nom or "") .. [[" required>
                </label><br/>
                <label>Password :<br/>
                  <input type="password" name="pwd" id="pwd" required>
                </label><br/>
                <label>Confirm :<br/>
                  <input type="password" name="confirm" id="confirm" required>
                </label><br/>
                <input type="submit" value="OK">
              </form>
            </div></body>
          </html>
          ]])
        end
      }
    }
    location /_static/ {
    }
    location /widgets/ {
    }
    location /api/ {
      auth_basic off;
      proxy_pass http://grist:8484;
      sendfile off;
      proxy_set_header X-Forwarded-User $remote_user;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      # WebSocket support
      #proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      #proxy_set_header Connection "upgrade";
      proxy_set_header Connection $http_connection;
    }
    client_max_body_size 1024M;
  }
}
